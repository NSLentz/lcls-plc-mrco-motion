<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_MotionTransform3D" Id="{d51993f0-483b-4be0-927a-876be7a82ac8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotionTransform3D
(*
    Implementation of a 3 Axis coordinate transform when attempting
    a move in one coordinate system, but the axes are in a different
    coordinate system.
*)
VAR_IN_OUT
    stMotionTransform3D: ST_MotionTransform3D;
END_VAR
VAR
    bInit: BOOL := TRUE;
    mx: LREAL;          // Setpoint x in motor coordinate system.
    my: LREAL;          // Setpoint y in motor coordinate system.
    mz: LREAL;          // Setpoint z in motor coordinate system.
    x: LREAL := 0;      // Setpoint x in resultant coordinate system.
    y: LREAL := 0;      // Setpoint y in resultant coordinate system.
    z: LREAL := 0;      // Setpoint z in resultant coordinate system.
    xMeas: LREAL;       // Measured x in resultant coordinate system.
    yMeas: LREAL;       // Measured y in resultant coordinate system.
    zMeas: LREAL;       // Measured z in resultant coordinate system.
    mxMeas: LREAL;      // Measured x in motor coordinates.
    myMeas: LREAL;      // Measured y in motor coordinates.
    mzMeas: LREAL;      // Measured z in motor coordinates.
    a: LREAL := 0;      // Alpha in radians.
    b:  LREAL := 0;     // Beta in radians.
    g: LREAL := 0;      // Gamma in radians.
    ca:  LREAL;         // cos(a)
    cb:  LREAL;         // cos(b)
    cg:  LREAL;         // cos(g)
    sa:  LREAL;         // sin(a)
    sb:  LREAL;         // sin(b)
    sg:  LREAL;         // sin(g)
    pi: LREAL := 3.1415926535;  // pi constant
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
IF bInit THEN
    bInit := FALSE;

    stMotionTransform3D.fFirstAxisSP := stMotionTransform3D.fFirstAxisMeas;
    stMotionTransform3D.fSecondAxisSP := stMotionTransform3D.fSecondAxisMeas;
    stMotionTransform3D.fThirdAxisSP := stMotionTransform3D.fThirdAxisMeas;
END_IF

// Convert angles in degrees to radians.
a := stMotionTransform3D.fADeg * pi / 180;
b := stMotionTransform3D.fBDeg * pi / 180;
g := stMotionTransform3D.fGDeg * pi / 180;

sa := sin(a);
sb := sin(b);
sg := sin(g);
ca := cos(a);
cb := cos(b);
cg := cos(g);

// Get the current measured position for each stage in starting coordinates.
mxMeas := stMotionTransform3D.fMotorFirstAxisMeas;
myMeas := stMotionTransform3D.fMotorSecondAxisMeas;
mzMeas := stMotionTransform3D.fMotorThirdAxisMeas;

// Convert the current measured position for each stage in starting coordinates to new coordinates.
stMotionTransform3D.fFirstAxisMeas := mxMeas*(cb*cg)             + myMeas*(-cb*sg)           + mzMeas*(sb);
stMotionTransform3D.fSecondAxisMeas := mxMeas*(ca*sg + cg*sa*sb)  + myMeas*(ca*cg - sa*sb*sg) + mzMeas*(-cb*sa);
stMotionTransform3D.fThirdAxisMeas := mxMeas*(-ca*cg*sb + sa*sg) + myMeas*(ca*sb*sg + cg*sa) + mzMeas*(ca*cb);

// Get the current desired position in new coordinates
x := stMotionTransform3D.fFirstAxisSP;
y := stMotionTransform3D.fSecondAxisSP;
z := stMotionTransform3D.fThirdAxisSP;

// Convert the desired position in new coordinates to the required position in starting coordinates.
// This allows the individual motors to move to where they need to be to achieve the desired position in new coordinates.
mx :=  x*cb*cg + y*ca*sg + y*cg*sa*sb - z*ca*cg*sb + z*sa*sg;
my := -x*cb*sg + y*ca*cg - y*sa*sb*sg + z*ca*sb*sg + z*cg*sa;
mz :=  x*sb    - y*cb*sa + z*ca*cb;

stMotionTransform3D.fMotorFirstAxisSP := mx;
stMotionTransform3D.fMotorSecondAxisSP := my;
stMotionTransform3D.fMotorThirdAxisSP := mz;
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>