<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_MotionStageTransform3D" Id="{f80a8b05-41ce-4a1a-897a-4dae9eac98fd}" SpecialFunc="None">
    <Declaration><![CDATA[
FUNCTION_BLOCK FB_MotionStageTransform3D
VAR_IN_OUT
    stMotionTransformPosition3D : ST_MotionTransform3D;
    stMotionTransformVelocity3D : ST_MotionTransform3D;
    stMotionStageRealFirstRotation : ST_MotionStage;
    stMotionStageRealSecondRotation : ST_MotionStage;
    stMotionStageRealThirdRotation : ST_MotionStage;
    stMotionStageVirtFirstRotation : ST_MotionStage;
    stMotionStageVirtSecondRotation : ST_MotionStage;
    stMotionStageVirtThirdRotation : ST_MotionStage;
END_VAR
VAR_INPUT
    bVirtualAxesActive : BOOL;
    nVirtualEncoderUnitConversion: LREAL := 1000000; // mm to nm
    firstRotationAngle : LREAL;
    secondRotationAngle : LREAL;
    thirdRotationAngle : LREAL;
END_VAR
VAR_OUTPUT
    nVirtualEncoderMotionStageVirtFirstRotationnm : UDINT;
    nVirtualEncoderMotionStageVirtSecondRotationnm : UDINT;
    nVirtualEncoderMotionStageVirtThirdRotationnm : UDINT;
END_VAR
VAR
    fbPMotionTransform3D : FB_MotionTransform3D;
    fbVMotionTransform3D : FB_MotionTransform3D;
    fDPosMotionStageVirtFirstRotation : LREAL;
    fDPosMotionStageVirtSecondRotation : LREAL;
    fDPosMotionStageVirtThirdRotation : LREAL;
    rtMotionStageVirtFirstRotationExecute: R_TRIG;
    rtMotionStageVirtSecondRotationExecute: R_TRIG;
    rtMotionStageVirtThirdRotationExecute: R_TRIG;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
// Set the degree offsets for the coordinate transform from stage coordinates to beam coordinates.
stMotionTransformPosition3D.fADeg := firstRotationAngle;
stMotionTransformPosition3D.fBDeg := secondRotationAngle;
stMotionTransformPosition3D.fGDeg := thirdRotationAngle;
stMotionTransformVelocity3D.fADeg := firstRotationAngle;
stMotionTransformVelocity3D.fBDeg := secondRotationAngle;
stMotionTransformVelocity3D.fGDeg := thirdRotationAngle;

// Set the actual measured position and velocity for each axis to support the coordinate transform.
stMotionTransformPosition3D.fMotorFirstAxisMeas := stMotionStageRealFirstRotation.Axis.NcToPlc.ActPos;
stMotionTransformPosition3D.fMotorSecondAxisMeas := stMotionStageRealSecondRotation.Axis.NcToPlc.ActPos;
stMotionTransformPosition3D.fMotorThirdAxisMeas := stMotionStageRealThirdRotation.Axis.NcToPlc.ActPos;
stMotionTransformVelocity3D.fMotorFirstAxisMeas := stMotionStageRealFirstRotation.Axis.NcToPlc.ActVelo;
stMotionTransformVelocity3D.fMotorSecondAxisMeas := stMotionStageRealSecondRotation.Axis.NcToPlc.ActVelo;
stMotionTransformVelocity3D.fMotorThirdAxisMeas := stMotionStageRealThirdRotation.Axis.NcToPlc.ActVelo;

// Set the desired position in beam coordinates for each axis to support the coordinate transform.
rtMotionStageVirtFirstRotationExecute(CLK:=stMotionStageVirtFirstRotation.bExecute);
rtMotionStageVirtSecondRotationExecute(CLK:=stMotionStageVirtSecondRotation.bExecute);
rtMotionStageVirtThirdRotationExecute(CLK:=stMotionStageVirtThirdRotation.bExecute);
IF rtMotionStageVirtFirstRotationExecute.Q THEN
    stMotionTransformPosition3D.fFirstAxisSP := stMotionStageVirtFirstRotation.fPosition;
    stMotionTransformVelocity3D.fFirstAxisSP := stMotionStageVirtFirstRotation.fVelocity;
ELSIF rtMotionStageVirtSecondRotationExecute.Q OR rtMotionStageVirtThirdRotationExecute.Q THEN
    stMotionTransformPosition3D.fFirstAxisSP := stMotionStageVirtFirstRotation.Axis.NcToPlc.ActPos;
    stMotionTransformVelocity3D.fFirstAxisSP := 0;
    stMotionStageVirtFirstRotation.fPosition := stMotionStageVirtFirstRotation.Axis.NcToPlc.ActPos;
    stMotionStageVirtFirstRotation.fVelocity := 0;
END_IF
IF rtMotionStageVirtSecondRotationExecute.Q THEN
    stMotionTransformPosition3D.fSecondAxisSP := stMotionStageVirtSecondRotation.fPosition;
    stMotionTransformVelocity3D.fSecondAxisSP := stMotionStageVirtSecondRotation.fVelocity;
ELSIF rtMotionStageVirtFirstRotationExecute.Q OR rtMotionStageVirtThirdRotationExecute.Q THEN
    stMotionTransformPosition3D.fSecondAxisSP := stMotionStageVirtSecondRotation.Axis.NcToPlc.ActPos;
    stMotionTransformVelocity3D.fSecondAxisSP := 0;
    stMotionStageVirtSecondRotation.fPosition := stMotionStageVirtSecondRotation.Axis.NcToPlc.ActPos;
    stMotionStageVirtSecondRotation.fVelocity := 0;
END_IF
IF rtMotionStageVirtThirdRotationExecute.Q THEN
    stMotionTransformPosition3D.fThirdAxisSP := stMotionStageVirtThirdRotation.fPosition;
    stMotionTransformVelocity3D.fSecondAxisSP := stMotionStageVirtThirdRotation.fVelocity;
ELSIF rtMotionStageVirtFirstRotationExecute.Q OR rtMotionStageVirtSecondRotationExecute.Q THEN
    stMotionTransformPosition3D.fThirdAxisSP := stMotionStageVirtThirdRotation.Axis.NcToPlc.ActPos;
    stMotionTransformVelocity3D.fThirdAxisSP := 0;
    stMotionStageVirtThirdRotation.fPosition := stMotionStageVirtThirdRotation.Axis.NcToPlc.ActPos;
    stMotionStageVirtThirdRotation.fVelocity := 0;
END_IF

// Set the desired velocity in beam coordinates. First need to figure out which direction we are moving
// so that we can apply the correct sign (positive or negative) to the velocity values.
fDPosMotionStageVirtFirstRotation := stMotionTransformPosition3D.fFirstAxisSP - stMotionStageVirtFirstRotation.Axis.NcToPlc.ActPos;
fDPosMotionStageVirtSecondRotation := stMotionTransformPosition3D.fSecondAxisSP - stMotionStageVirtSecondRotation.Axis.NcToPlc.ActPos;
fDPosMotionStageVirtThirdRotation := stMotionTransformPosition3D.fThirdAxisSP - stMotionStageVirtThirdRotation.Axis.NcToPlc.ActPos;

// Apply the correct sign to the velocity value so that the coordinate transform computes correctly.
IF fDPosMotionStageVirtFirstRotation < 0 THEN
    stMotionTransformVelocity3D.fFirstAxisSP := stMotionTransformVelocity3D.fFirstAxisSP * -1;
END_IF
IF fDPosMotionStageVirtSecondRotation < 0 THEN
    stMotionTransformVelocity3D.fSecondAxisSP := stMotionTransformVelocity3D.fSecondAxisSP * -1;
END_IF
IF fDPosMotionStageVirtThirdRotation < 0 THEN
    stMotionTransformVelocity3D.fThirdAxisSP := stMotionTransformVelocity3D.fThirdAxisSP * -1;
END_IF

// Transform Coordinates to new coordinate system before calling fbMotion so that it knows where to move in stage coordinates to get to the desired beam coordinates.
fbPMotionTransform3D(
    stMotionTransform3D:=stMotionTransformPosition3D
);
fbVMotionTransform3D(
    stMotionTransform3D:=stMotionTransformVelocity3D
);

// Get the converted measured position in beam coordinates and write it to the virtual encoder we have mapped to the NC axes.
nVirtualEncoderMotionStageVirtFirstRotationnm := LREAL_TO_UDINT(stMotionTransformPosition3D.fFirstAxisMeas * nVirtualEncoderUnitConversion);
nVirtualEncoderMotionStageVirtSecondRotationnm := LREAL_TO_UDINT(stMotionTransformPosition3D.fSecondAxisMeas * nVirtualEncoderUnitConversion);
nVirtualEncoderMotionStageVirtThirdRotationnm := LREAL_TO_UDINT(stMotionTransformPosition3D.fThirdAxisMeas * nVirtualEncoderUnitConversion);

stMotionStageVirtFirstRotation.nRawEncoderULINT := UDINT_TO_ULINT(nVirtualEncoderMotionStageVirtFirstRotationnm);
stMotionStageVirtSecondRotation.nRawEncoderULINT := UDINT_TO_ULINT(nVirtualEncoderMotionStageVirtSecondRotationnm);
stMotionStageVirtThirdRotation.nRawEncoderULINT := UDINT_TO_ULINT(nVirtualEncoderMotionStageVirtThirdRotationnm);

// If the virtual axes are enabled, then do the following logic. Allows the user to turn off the coordinate transform and
// run just controlling each individual motor which are in stage coordinates.
IF bVirtualAxesActive THEN
    // Get the result of the coordinate transform assigned as the setpoint position for each motor in stage coordinates.
    stMotionStageRealFirstRotation.fPosition := stMotionTransformPosition3D.fMotorFirstAxisSP;
    stMotionStageRealSecondRotation.fPosition := stMotionTransformPosition3D.fMotorSecondAxisSP;
    stMotionStageRealThirdRotation.fPosition := stMotionTransformPosition3D.fMotorThirdAxisSP;

    // Get the result of the coordinate transform assigned as the setpoint velocity for each motor in stage coordinates.
    // Take the absolute value because the velocity value is in reality just a speed setting.
    stMotionStageRealFirstRotation.fVelocity := ABS(stMotionTransformVelocity3D.fMotorFirstAxisSP);
    stMotionStageRealSecondRotation.fVelocity := ABS(stMotionTransformVelocity3D.fMotorSecondAxisSP);
    stMotionStageRealThirdRotation.fVelocity := ABS(stMotionTransformVelocity3D.fMotorThirdAxisSP);

    // If any virtual axis was requested to move, we have to call bExecute on all the motors,
    // because any move in beam coordinates will likely require a move on all three motors.
    IF rtMotionStageVirtFirstRotationExecute.Q OR rtMotionStageVirtSecondRotationExecute.Q OR rtMotionStageVirtThirdRotationExecute.Q THEN
        stMotionStageRealFirstRotation.bMoveCmd := TRUE;
        stMotionStageRealSecondRotation.bMoveCmd := TRUE;
        stMotionStageRealThirdRotation.bMoveCmd := TRUE;
    END_IF

    // If any virtual axis detects an error, make sure to propagate the error status to the actual
    // axes.
    (*IF stMotionStageVirtFirstRotation.bError OR stMotionStageVirtSecondRotation.bError OR stMotionStageVirtThirdRotation.bError THEN
        stMotionStageRealFirstRotation.bExecute := FALSE;
        stMotionStageRealSecondRotation.bExecute := FALSE;
        stMotionStageRealThirdRotation.bExecute := FALSE;
        stMotionStageRealFirstRotation.bError := TRUE;
        stMotionStageRealSecondRotation.bError := TRUE;
        stMotionStageRealThirdRotation.bError := TRUE;
        stMotionStageRealFirstRotation.sCustomErrorMessage := 'An error occured in Sample Paddle Virtual X, Y, or Z. Check Virtual X, Y, and Z.';
        stMotionStageRealSecondRotation.sCustomErrorMessage := 'An error occured in Sample Paddle Virtual X, Y, or Z, Check Virtual X, Y, and Z.';
        stMotionStageRealThirdRotation.sCustomErrorMessage := 'An error occured in Sample Paddle Virtual X, Y, or Z, Check Virtual X, Y, and Z.';
    END_IF*)

    // If any actual axis detects an error, make sure to propagate the error status to the virtual
    // axes.
    IF stMotionStageRealFirstRotation.bError OR stMotionStageRealSecondRotation.bError OR stMotionStageRealThirdRotation.bError THEN
        stMotionStageVirtFirstRotation.bExecute := FALSE;
        stMotionStageVirtSecondRotation.bExecute := FALSE;
        stMotionStageVirtThirdRotation.bExecute := FALSE;
        stMotionStageVirtFirstRotation.bError := TRUE;
        stMotionStageVirtSecondRotation.bError := TRUE;
        stMotionStageVirtThirdRotation.bError := TRUE;
        stMotionStageVirtFirstRotation.sCustomErrorMessage := 'An error occured in Sample Paddle X, Y, or Z. Check X, Y, and Z.';
        stMotionStageVirtSecondRotation.sCustomErrorMessage := 'An error occured in Sample Paddle X, Y, or Z, Check X, Y, and Z.';
        stMotionStageVirtThirdRotation.sCustomErrorMessage := 'An error occured in Sample Paddle X, Y, or Z, Check X, Y, and Z.';
    END_IF
END_IF

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>